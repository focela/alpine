#!/command/with-contenv bash
#-----------------------------------------------------------------------------
# Container Finalization Script
#
# Purpose: Final initialization script that validates all init scripts completed
#          successfully and starts container services
# Context: Runs last in s6-overlay initialization sequence (99-container)
# Note: Critical script that performs sanity checks and determines if container
#       startup should proceed or fail with detailed error reporting
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# CONFIGURATION - FRAMEWORK SETUP
#-----------------------------------------------------------------------------
# Load default configuration and container framework functions
source /assets/defaults/00-container
source /assets/functions/00-container

# Configure logging context and disable debug output during execution
output_off
PROCESS_NAME="container"

#-----------------------------------------------------------------------------
# PHASE 1: INITIALIZATION SANITY CHECK
#-----------------------------------------------------------------------------
# Verify all initialization scripts completed successfully before starting services
# This check can be skipped by setting CONTAINER_SKIP_SANITY_CHECK=true
if var_false "${CONTAINER_SKIP_SANITY_CHECK}" ; then

  #---------------------------------------------------------------------------
  # DISCOVERY OF INITIALIZATION SCRIPTS
  #---------------------------------------------------------------------------
  # Count and catalog all initialization scripts in /etc/cont-init.d/
  # Subtract 1 to exclude this script (99-container) from the count
  files_init=$(find /etc/cont-init.d/ -maxdepth 1 -type f | wc -l)
  files_init=$(( $files_init-1 ))

  # Initialize arrays to store initialization script names
  # Note: Using original array assignment pattern to preserve exact behavior
  declare -a files_init_name
  declare -a length_of_files_init_name

  # Extract names of all initialization scripts
  for f in /etc/cont-init.d/*; do
    files_init_name[length_of_files_init_name + 1]=filename
    files_init_name[${#files_init_name[@]}+1]=$(echo "$f" | sed "s#filename##g" | sed "s#/etc/cont-init.d/##g" | sed "s#99-container##g" );
  done

  #---------------------------------------------------------------------------
  # DISCOVERY OF COMPLETED INITIALIZATION MARKERS
  #---------------------------------------------------------------------------
  # Count and catalog completion markers in /tmp/.container/*-init
  # Each successful init script creates a marker file
  init_complete=$(find /tmp/.container/*-init -maxdepth 1 -type f | wc -l)

  # Initialize arrays to store completed initialization names
  # Note: Using original array assignment pattern to preserve exact behavior
  declare -a init_complete_name
  declare -a length_of_init_complete_name

  # Extract names of completed initialization scripts
  for f in /tmp/.container/*-init; do
    init_complete_name[length_of_init_complete_name + 1]=filename
    init_complete_name[${#init_complete_name[@]}+1]=$(echo "$f" | sed "s#filename##g" | sed "s#/tmp/.container/##g" | sed "s#-init##g");
  done

  #---------------------------------------------------------------------------
  # COMPARISON AND VALIDATION
  #---------------------------------------------------------------------------
  # Compare initialization scripts with completion markers to find uninitialized scripts
  # This logic identifies scripts that didn't complete successfully
  uninitialized_scripts=()
  for i in "${files_init_name[@]}"; do
    skip=
    for j in "${init_complete_name[@]}"; do
      [[ $i == "$j" ]] && { skip=1; break; }
    done
    [[ -n $skip ]] || uninitialized_scripts+=("$i")
  done
  declare uninitialized_scripts

  #---------------------------------------------------------------------------
  # INITIALIZATION VALIDATION AND ERROR REPORTING
  #---------------------------------------------------------------------------
  # Check if the number of init scripts matches the number of completion markers
  if [ $files_init != "$init_complete" ]; then

    # If more completions than scripts, something unusual happened but continue
    if [ "$init_complete" -gt "$files_init" ] ; then
      :
    else

      #-----------------------------------------------------------------------
      # IMAGE INFORMATION DISCOVERY
      #-----------------------------------------------------------------------
      # Attempt to discover image version and repository information for error display
      if [ -n "${IMAGE_NAME}" ] ; then
        # Try multiple changelog file naming patterns
        if [ -f "/assets/.changelogs/${IMAGE_NAME/\//_}.md" ] ; then
          image_version=$(head -n1 /assets/.changelogs/"${IMAGE_NAME/\//_}".md | awk '{print $2}')
        elif [ -f /assets/.changelogs/docker-"${IMAGE_NAME/\//_}".md ] ; then
          image_version=$(head -n1 /assets/.changelogs/docker-"${IMAGE_NAME/\//_}".md | awk '{print $2}')
        else
          if [ -f /assets/.changelogs/tiredofit_docker-"${IMAGE_NAME/\//_}".md ] ; then
            image_version=$(head -n1 /assets/.changelogs/tiredofit_docker-"${IMAGE_NAME/\//_}".md | awk '{print $2}')
          fi
        fi

        # Build image information string for error display
        image_string="Image: ${IMAGE_NAME}"

        if [ -n "${image_version}" ] ; then
          image_string="${image_string} | Version ${image_version} Type 'changelog' for details"
        fi

        image_string="${image_string}"

        # Add repository URL if available
        if [ -n "${IMAGE_REPO_URL}" ] ; then
          image_url="Repository/Issues/Support: ${IMAGE_REPO_URL}"
        fi
      fi

      #-----------------------------------------------------------------------
      # CRITICAL ERROR DISPLAY AND EXIT
      #-----------------------------------------------------------------------
      # Display comprehensive error message for initialization failure
      # This is a critical failure that prevents container startup
      echo "**********************************************************************************************************************"
      echo "**********************************************************************************************************************"
      echo "****                                                                                                              ****"
      echo "****       ERROR - Some initialization scripts haven't completed - All services are now halted                    ****"
      echo "****             - The following scripts in '/etc/cont-init.d' did not pass their completion check                ****"
      echo "****                                                                                                              ****"
      echo "**********************************************************************************************************************"
      echo "**********************************************************************************************************************"
      echo ""

      # Display list of uninitialized scripts
      echo "${uninitialized_scripts[@]}" | tr ' ' '\n' | uniq -u
      echo ""

      echo "**********************************************************************************************************************"
      echo "**********************************************************************************************************************"
      echo "****                                                                                                              ****"
      echo "****       This could have happened for a variety of reasons. Please make sure you have followed the README       ****"
      echo "****       relating to this image and have proper configuration such as environment variables and volumes set     ****"
      echo "****                                                                                                              ****"
      echo "****       If you feel that you have encountered a bug, please submit an issue on the revision control system     ****"
      echo "****       and provide full debug logs by setting the environment variable 'DEBUG_MODE=TRUE'                      ****"
      echo "****                                                                                                              ****"
      echo "**********************************************************************************************************************"
      echo "**********************************************************************************************************************"
      echo ""

      # Display image and repository information for support
      echo "$image_string"
      echo "$image_url"

      # Exit with error code to prevent container startup
      exit 1
    fi
  fi

  # Re-enable output after sanity check completion
  output_on
fi

#-----------------------------------------------------------------------------
# PHASE 2: SERVICE ACTIVATION
#-----------------------------------------------------------------------------
# Activate services by creating symlinks from available services to active services
# Services are enabled based on their initialization status and configuration

for services in /etc/services.available/*/
do
  # Extract service name from path
  service=${services%*/}

  # Check if service has an initialization marker
  if [ -f "/tmp/.container/${service##*/}-init" ]; then

    #-------------------------------------------------------------------------
    # SERVICE STARTUP CONTROL
    #-------------------------------------------------------------------------
    # Check if service is marked as "DO NOT START"
    if grep -q "DONOTSTART" "/tmp/.container/${service##*/}-init"; then
      print_debug "Skipping '${service##*/}' service for startup routines"
    else
      print_debug "Getting ready to start '${service##*/}' service"

      # Create symlink to activate service
      ln -sf "${service}" /etc/services.d
    fi
  else

    #-------------------------------------------------------------------------
    # SERVICES WITHOUT INITIALIZATION SCRIPTS
    #-------------------------------------------------------------------------
    # Services without init scripts are started by default
    print_debug "No Initialization Script Found - Getting ready to start '${service##*/}' service"
    ln -sf "${service}" /etc/services.d
  fi
done

#-----------------------------------------------------------------------------
# PHASE 3: POST-INITIALIZATION SCRIPT EXECUTION
#-----------------------------------------------------------------------------
# Execute custom post-initialization scripts if specified
# These scripts run after all initialization but before services start

if [ -n "${CONTAINER_POST_INIT_SCRIPT}" ] ; then
  print_debug "Found Post Init Scripts"

  # Parse comma-separated list of post-init scripts
  post_scripts=$(echo "${CONTAINER_POST_INIT_SCRIPT}" | tr "," "\n")

  # Execute each post-init script
  for post_script in $post_scripts
  do
    if [ -f "${post_script}" ] ; then
      print_debug "Executing post init script '${post_script}'"

      # Ensure script is executable and run it
      chmod +x "${post_script}"
      "${post_script}"
    else
      print_error "Tried to run post script '${post_script}' but it does not exist!"
    fi
  done
fi

#-----------------------------------------------------------------------------
# PHASE 4: POST-INITIALIZATION COMMAND EXECUTION
#-----------------------------------------------------------------------------
# Execute custom post-initialization commands if specified
# These commands run after scripts but before final initialization completion

if [ -n "${CONTAINER_POST_INIT_COMMAND}" ] ; then
  print_debug "Found Post Init Command"

  # Parse comma-separated list of post-init commands
  post_commands=$(echo "${CONTAINER_POST_INIT_COMMAND}" | tr "," "\n")

  # Execute each post-init command
  for post_command in "${post_commands}"
  do
    print_debug "Executing post init command '${post_command}'"

    # Use eval to execute command with variable expansion
    eval "${post_command}"
  done
fi

#-----------------------------------------------------------------------------
# FINALIZATION
#-----------------------------------------------------------------------------
# Mark container initialization as completed and enable output
# This signals that the container is ready for service operation
liftoff

# Re-enable output for service startup and runtime operation
output_on
