#!/command/with-contenv bash
#-----------------------------------------------------------------------------
# Firewall Configuration Script
#
# Purpose: Configures firewall rules (iptables) and fail2ban intrusion prevention
# Context: Runs in s6-overlay initialization sequence (07-firewall)
# Note: Handles both static iptables rules and dynamic fail2ban configuration
#       with extensive customization via environment variables and monitoring integration
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# CONFIGURATION - FRAMEWORK SETUP
#-----------------------------------------------------------------------------
# Load the core container framework library for utility functions
source /assets/functions/00-container

# Configure logging context and disable debug output during execution
output_off

# Prepare service for firewall setup (supports both firewall and fail2ban)
prepare_service

# Disable shellcheck warning for PROCESS_NAME variable (used by framework)
# shellcheck disable=SC2034
PROCESS_NAME="firewall"

#-----------------------------------------------------------------------------
# CONFIGURATION - FIREWALL BACKEND DETECTION
#-----------------------------------------------------------------------------
# Determine the firewall command based on the selected backend
# This allows for future extensibility to other firewall backends
firewall_command=$(which "${CONTAINER_FIREWALL_BACKEND,,}")

#-----------------------------------------------------------------------------
# MAIN EXECUTION - FIREWALL SETUP
#-----------------------------------------------------------------------------
# Only proceed with firewall setup if explicitly enabled
if var_true "${CONTAINER_ENABLE_FIREWALL}" ; then
  print_notice "Container configured for firewall with '${CONTAINER_FIREWALL_BACKEND}'"

  #---------------------------------------------------------------------------
  # FIREWALL BACKEND CONFIGURATION
  #---------------------------------------------------------------------------
  case "${CONTAINER_FIREWALL_BACKEND,,}" in
    "iptables" )

      #-----------------------------------------------------------------------
      # STATIC RULES FILE PROCESSING
      #-----------------------------------------------------------------------
      # Load custom iptables rules from file if present
      # This allows for pre-defined firewall configurations
      if [ -f "${IPTABLES_RULES_PATH}"/"${IPTABLES_RULES_FILE}" ]; then
        print_notice "Found custom iptables.rules file"
        silent iptables-restore "${IPTABLES_RULES_PATH}"/"${IPTABLES_RULES_FILE}"
      fi
    ;;

    #-------------------------------------------------------------------------
    # UNSUPPORTED FIREWALL BACKENDS
    #-------------------------------------------------------------------------
    *)
      print_error "Unknown firewall backend"
      exit 1
    ;;
  esac

  #---------------------------------------------------------------------------
  # DYNAMIC FIREWALL RULES PROCESSING
  #---------------------------------------------------------------------------
  # Process FIREWALL_RULE_* environment variables for dynamic rule creation
  # Rules are processed in numerical order based on variable naming
  set -o posix
  set -f

  # Check for existence of FIREWALL_RULE environment variables
  if printenv | grep -q "^FIREWALL_RULE" ; then
    print_debug "Found existence of FIREWALL_RULE environment variables"

    # Create temporary file to store extracted firewall rules
    firewallenv=$(mktemp)

    # Extract FIREWALL_RULE_* variables, sort numerically, and remove prefix
    # Pattern: FIREWALL_RULE_01, FIREWALL_RULE_02, etc.
    printenv | sort | grep '^FIREWALL_RULE_[0-9][0-9]*' | sed "s|FIREWALL_RULE_||g" > ${firewallenv}

    # Debug: Display extracted rules for troubleshooting
    cat ${firewallenv}

    # Process each firewall rule entry
    while IFS= read -r firewall_entry; do
      rule_number="$(echo ${firewall_entry} | cut -d = -f1 )"
      rule_value="$(echo ${firewall_entry} | cut -d = -f2 )"

      print_debug "Adding Rule Number: ${rule_number} with to be parsed by ${CONTAINER_FIREWALL_BACKEND}"

      # Execute the firewall rule using the detected firewall command
      # Note: rule_value should contain the complete iptables command arguments
      silent "${firewall_command}" ${rule_value}
    done < "${firewallenv}"

    # Cleanup temporary file and variables
    rm -rf "${firewallenv}"
    set +f
    unset rule_number rule_value
    unset "${!FIREWALL_RULE_RULE_@}"
  fi

  #---------------------------------------------------------------------------
  # FAIL2BAN INTRUSION PREVENTION SETUP
  #---------------------------------------------------------------------------
  # Configure fail2ban if enabled for automated IP blocking
  if var_true "${CONTAINER_ENABLE_FAIL2BAN}" ; then
    print_notice "Container configured to block hosts via 'fail2ban'"

    #-------------------------------------------------------------------------
    # FAIL2BAN LOGGING CONFIGURATION
    #-------------------------------------------------------------------------
    print_debug "Fail2ban: Configure Logging"
    mkdir -p "${FAIL2BAN_LOG_PATH}"
    touch "${FAIL2BAN_LOG_PATH}"/"${FAIL2BAN_LOG_FILE}"

    #-------------------------------------------------------------------------
    # FAIL2BAN FILESYSTEM SETUP
    #-------------------------------------------------------------------------
    print_debug "Fail2ban: Configuring Filesystem"

    # Handle custom configuration path (different from default /etc/fail2ban/)
    if [ "${FAIL2BAN_CONFIG_PATH}" != "/etc/fail2ban/" ]; then
      echo "not /etc/fail2ban"
      print_debug "Fail2ban: Creating Config Dir"

      # Copy default configuration to custom location
      mkdir -p "${FAIL2BAN_CONFIG_PATH}"
      silent cp -R /etc/fail2ban/* "${FAIL2BAN_CONFIG_PATH}"

      # Create symlink from standard location to custom path
      print_debug "Fail2ban: Linking Config to Persistent Storage"
      rm -rf /etc/fail2ban
      ln -sf "${FAIL2BAN_CONFIG_PATH}" /etc/fail2ban
    fi

    # Ensure required directories exist
    mkdir -p /etc/fail2ban/filter.d
    mkdir -p /etc/fail2ban/jail.d

    #-------------------------------------------------------------------------
    # FAIL2BAN DATABASE CONFIGURATION
    #-------------------------------------------------------------------------
    print_debug "Fail2ban: Creating Data Dir"

    # Configure database backend based on type
    case "${FAIL2BAN_DB_TYPE,,}" in
      file )
        # File-based database for persistent ban storage
        fail2ban_db="${FAIL2BAN_DB_PATH}/${FAIL2BAN_DB_FILE}"
        mkdir -p "${FAIL2BAN_DB_PATH}"
      ;;
      memory )
        # In-memory database - faster but non-persistent
        fail2ban_db=":memory:"
      ;;
      none )
        # No database - minimal functionality
        fail2ban_db="None"
      ;;
    esac

    #-------------------------------------------------------------------------
    # FAIL2BAN LOGGING TYPE CONFIGURATION
    #-------------------------------------------------------------------------
    case "${FAIL2BAN_LOG_TYPE,,}" in
      file )
        print_debug "Fail2ban: Creating Log Directory"
        mkdir -p "${FAIL2BAN_LOG_PATH}"
        touch "${FAIL2BAN_LOG_PATH}"/"${FAIL2BAN_LOG_FILE}"

        # Setup log rotation for fail2ban logs (no compression)
        create_logrotate fail2ban "${FAIL2BAN_LOG_PATH}"/"${FAIL2BAN_LOG_FILE}" none
      ;;
      console )
        # Log to console/stdout instead of file
        FAIL2BAN_LOG_FILE="STDOUT"
      ;;
    esac

    #-------------------------------------------------------------------------
    # FAIL2BAN JAIL CONFIGURATION GENERATION
    #-------------------------------------------------------------------------
    print_debug "Fail2Ban: Creating Default Jail Configuration"

    # Generate comprehensive jail.conf with all default settings
    # This configuration defines global defaults for all jails
    cat <<EOF > "${FAIL2BAN_CONFIG_PATH}"/jail.conf
## Custom Generated Fail2ban jail.conf Configuration! Do not edit, instead set ENV Vars
## Last Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')

[DEFAULT]
ignorself = ${FAIL2BAN_IGNORE_SELF}
ignoreip = ${FAIL2BAN_IGNORE_IP}
ignorecommand =
bantime  = ${FAIL2BAN_TIME_BAN}
findtime  = ${FAIL2BAN_TIME_FIND}
maxretry = ${FAIL2BAN_MAX_RETRY}
backend = ${FAIL2BAN_BACKEND}

# "usedns" specifies if jails should trust hostnames in logs,
#   warn when DNS lookups are performed, or ignore all hostnames in logs
#
# yes:   if a hostname is encountered, a DNS lookup will be performed.
# warn:  if a hostname is encountered, a DNS lookup will be performed,
#        but it will be logged as a warning.
# no:    if a hostname is encountered, will not be used for banning,
#        but it will be logged as info.
# raw:   use raw value (no hostname), allow use it for no-host filters/actions (example user)
usedns = ${FAIL2BAN_USE_DNS}

logencoding = auto
enabled = false
mode = normal
filter = %(__name__)s[mode=%(mode)s]
destemail = root@localhost
sender = root@<fq-hostname>
mta = sendmail
protocol = tcp
chain = <known/chain>
port = 0:65535
fail2ban_agent = Fail2Ban/%(fail2ban_version)s
banaction = iptables-multiport
banaction_allports = iptables-allports

# Basic ban action - just ban the IP
action_ = %(banaction)s[name=%(__name__)s, bantime="%(bantime)s", port="%(port)s", protocol="%(protocol)s", chain="%(chain)s"]

# Ban + email notification with whois info
action_mw = %(banaction)s[name=%(__name__)s, bantime="%(bantime)s", port="%(port)s", protocol="%(protocol)s", chain="%(chain)s"]
            %(mta)s-whois[name=%(__name__)s, sender="%(sender)s", dest="%(destemail)s", protocol="%(protocol)s", chain="%(chain)s"]

# Ban + email with whois and log lines
action_mwl = %(banaction)s[name=%(__name__)s, bantime="%(bantime)s", port="%(port)s", protocol="%(protocol)s", chain="%(chain)s"]
             %(mta)s-whois-lines[name=%(__name__)s, sender="%(sender)s", dest="%(destemail)s", logpath=%(logpath)s, chain="%(chain)s"]

# Ban + XARF reporting
action_xarf = %(banaction)s[name=%(__name__)s, bantime="%(bantime)s", port="%(port)s", protocol="%(protocol)s", chain="%(chain)s"]
             xarf-login-attack[service=%(__name__)s, sender="%(sender)s", logpath=%(logpath)s, port="%(port)s"]

# Cloudflare integration
action_cf_mwl = cloudflare[cfuser="%(cfemail)s", cftoken="%(cfapikey)s"]
                %(mta)s-whois-lines[name=%(__name__)s, sender="%(sender)s", dest="%(destemail)s", logpath=%(logpath)s, chain="%(chain)s"]

# Third-party reporting services
action_blocklist_de  = blocklist_de[email="%(sender)s", service=%(filter)s, apikey="%(blocklist_de_apikey)s", agent="%(fail2ban_agent)s"]
action_badips = badips.py[category="%(__name__)s", banaction="%(banaction)s", agent="%(fail2ban_agent)s"]
action_badips_report = badips[category="%(__name__)s", agent="%(fail2ban_agent)s"]
action_abuseipdb = abuseipdb

# Default action to use (basic ban only)
action = %(action_)s
EOF

    #-------------------------------------------------------------------------
    # FAIL2BAN MAIN CONFIGURATION GENERATION
    #-------------------------------------------------------------------------
    print_debug "Fail2ban: Configuring main config file"

    # Generate main fail2ban.conf with daemon settings
    cat <<EOF > "${FAIL2BAN_CONFIG_PATH}"/fail2ban.conf
## Custom Generated fail2ban.conf Configuration! Do not edit, instead set ENV Vars
## Last Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')

[Definition]
loglevel = ${FAIL2BAN_LOG_LEVEL}
logtarget = ${FAIL2BAN_LOG_PATH}/${FAIL2BAN_LOG_FILE}
syslogsocket = auto
socket = /var/run/fail2ban/fail2ban.sock
pidfile = /var/run/fail2ban/fail2ban.pid
dbfile = ${fail2ban_db}
dbpurgeage = ${FAIL2BAN_DB_PURGE_AGE}
EOF

    #-------------------------------------------------------------------------
    # CUSTOM JAIL CONFIGURATION PROCESSING
    #-------------------------------------------------------------------------
    # Process custom jail configurations with environment variable substitution
    # This allows dynamic configuration of jail files at runtime
    if [ -d "${FAIL2BAN_CONFIG_PATH}"/jail.d ] && dir_notempty ; then
      for fail2ban_file in "${FAIL2BAN_CONFIG_PATH}"/jail.d/*.conf ; do
        if [ ! -d "$fail2ban_file" ] ; then
          print_debug "Substituting Environment Variables for: '${fail2ban_file}'"

          # Create temporary file and preserve file attributes
          fail2ban_tmpfile=$(mktemp)
          cp --attributes-only --preserve "${fail2ban_file}" "${fail2ban_tmpfile}"

          # Perform environment variable substitution and replace original
          cat "$fail2ban_file}" | envsubst > "${fail2ban_tmpfile}" && mv "${fail2ban_tmpfile}" "${fail2ban_file}"
        fi
      done
    fi

    #-------------------------------------------------------------------------
    # MONITORING INTEGRATION
    #-------------------------------------------------------------------------
    # Integrate fail2ban with Zabbix monitoring if enabled
    if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
      cat <<EOF > "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}".d/focela-fail2ban.conf
# Zabbix Fail2ban Configuration - Automatically generated based on container startup options
# Find Companion Zabbix Server Templates at https://github.com/focela/docker-alpine or https://github.com/focela/docker-debian
# Autoregister=fail2ban

# Monitor banned IP count per jail
UserParameter=fail2ban.status[*],fail2ban-client status '\$1' | grep 'Currently banned:' | grep -E -o '[0-9]+'

# Discover all active jails for monitoring
UserParameter=fail2ban.discovery,fail2ban-client status | grep 'Jail list:' | sed -e 's/^.*:\W\+//' -e 's/\(\(\w\|-\)\+\)/{"{#JAIL}":"\1"}/g' -e 's/.*/{"data":[\0]}/'

# Monitor fail2ban version
UserParameter=fail2ban.version,fail2ban-server -V | head -n1 | awk '{print \$2}' | sed "s|v||"
EOF
    fi
  else
    #-------------------------------------------------------------------------
    # FAIL2BAN DISABLED - STOP SERVICE
    #-------------------------------------------------------------------------
    # Stop the firewall service if fail2ban is not enabled
    service_stop "$(basename "$0")"
  fi
else
  #---------------------------------------------------------------------------
  # FIREWALL DISABLED - STOP SERVICE
  #---------------------------------------------------------------------------
  # Stop the firewall service if firewall is not enabled
  service_stop "$(basename "$0")"
fi

#-----------------------------------------------------------------------------
# FINALIZATION
#-----------------------------------------------------------------------------
# Mark this initialization script as completed in container state tracking
liftoff

# Re-enable output for subsequent initialization scripts
output_on
