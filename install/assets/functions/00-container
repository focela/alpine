#!/command/with-contenv bash
#
# Container helper functions
# Core utility functions for container operations and management
#

# Import container defaults
source /assets/defaults/00-container

#------------------------------------------------------------------------------
# TERMINAL COLORS
#------------------------------------------------------------------------------
# Background colors for terminal output formatting
bdg="\e[42m"       # Background Color Dark Green
bdb="\e[44m"       # Background Color Dark Blue
bdm="\e[45m"       # Background Color Dark Magenta
bdgy="\e[100m"     # Background Color Dark Gray
blr="\e[101m"      # Background Color Light Red
boff="\e[49m"      # Background Color Off

#------------------------------------------------------------------------------
# CONTAINER LIFECYCLE FUNCTIONS
#------------------------------------------------------------------------------
# Check if container has completed initialization
check_container_initialized() {
    print_debug "Checking to see if container initialization scripts have completed"
    output_off
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Checking to see if container initialization scripts have completed"
        sleep 1
    done
    output_on
}

# Check if a specific service has been initialized
# Usage:
#   check_service_initialized init: Look for matching filename in /tmp/.container/<folder-name>-init
#   check_service_initialized <service folder>: Look for matching filename in /tmp/.container/<folder-name>
check_service_initialized() {
    print_debug "Checking to see if service has initialized"
    output_off

    local service_suffix=""
    local service=""
    local csi_bypass=FALSE

    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    while [ ! -f /tmp/.container/"${service}"${service_suffix} ]; do
        sleep 1
        print_debug "Looking for existence of /tmp/.container/${service}${service_suffix}"
    done

    unset csi_bypass
    output_on
}

# Perform final container startup operations
# Records script/service initialization state
liftoff() {
    output_off
    mkdir -p /tmp/.container

    local liftoff_prefix=""
    if [ "$DONOTSTART" = "TRUE" ]; then
        liftoff_prefix="DONOTSTART "
    fi

    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            echo "${liftoff_prefix} $(basename "$0")-init initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$0")"-init
        ;;
        *)
            if [ ! -f /tmp/.container/"$(basename "$PWD")" ]; then
                echo "$(basename "$PWD") initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            else
                echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            fi
        ;;
    esac
    output_on
}

# Prepare a service for operation by loading defaults and functions
# Usage: prepare_service [option]
# Options: defaults, functions, both/all
prepare_service() {
    if [ -n "$1" ]; then
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
            ;;
            *)
                case "${1,,}" in
                    "both" | "all" )
                        get_defaults "$2"
                        get_functions "$2"
                    ;;
                    "defaults" )
                        get_defaults "$2"
                    ;;
                    "functions" )
                        get_functions "$2"
                    ;;
                esac
            ;;
        esac
    else
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
            ;;
            *)
                get_defaults
            ;;
        esac
    fi
}

# Start a service
service_start() {
    ln -sf /etc/services.available/"${1}" /etc/services.d/
}

# Stop a service
service_stop() {
    echo "DONOTSTART added by $(basename \""$0"\")" >> /tmp/.container/"${1}"-init
}

#------------------------------------------------------------------------------
# ENVIRONMENT AND CONFIGURATION FUNCTIONS
#------------------------------------------------------------------------------
# Process environment variables with file prefixes (Docker Secrets Support)
# Usage: file_env VAR [DEFAULT]
# Example: file_env 'XYZ_DB_PASSWORD' 'example'
file_env() {
    if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" = "true" ]; then
        local var="$1"
        local fileVar="${var}_FILE"
        local def="${2:-}"
        local val="$def"

        if [ "${!fileVar:-}" ]; then
            val="$(cat "${!fileVar}")"
        elif [ "${!var:-}" ]; then
            val="${!var}"
        fi

        if [ -z "${val}" ]; then
            print_error "error: neither $var nor $fileVar are set but are required"
            exit 1
        fi

        export "$var"="$val"
        unset "$fileVar"
    fi
}

# Load default configuration values from /assets/defaults
# Usage: get_defaults [option]
# Options: all, app/single, or comma-separated list of config files
get_defaults() {
    if [ -n "$1" ]; then
        case "${1,,}" in
            "all" )
                for d in /assets/defaults/*; do
                    print_debug "Container: Getting defaults for '${d}' ALL"
                    case "$(basename "${d}")" in
                        0*-* | 99-* )
                            output_off
                            source "${d}"
                            output_on
                        ;;
                        * )
                            source "${d}"
                        ;;
                    esac
                done
            ;;
            "app" | "single" )
                _process_single_default
            ;;
            * )
                _process_default_list "$1"
            ;;
        esac
    else
        for d in /assets/defaults/*; do
            print_debug "Container: Getting defaults for $d"
            case "$(basename "${d}")" in
                0*-* | 99-* )
                    output_off
                    source /assets/defaults/00-container
                    source "${d}"
                    output_on
                ;;
                * )
                    source /assets/defaults/00-container
                    source "${d}"
                ;;
            esac
        done
    fi
}

# Helper function to process single default config
_process_single_default() {
    local script_path
    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            script_path="$(basename "$0")"
        ;;
        *)
            script_path="$(basename "$PWD")"
        ;;
    esac

    if [ -f "/assets/defaults/${script_path}" ]; then
        print_debug "Container: Getting defaults for '${script_path}'"
        case "${script_path}" in
            0*-* | 99-* )
                output_off
                source /assets/defaults/"${script_path}"
                output_on
            ;;
            * )
                source /assets/defaults/"${script_path}"
            ;;
        esac
    else
        print_debug "Container: No defaults available for '${script_path}'"
    fi
}

# Helper function to process a list of default configs
_process_default_list() {
    local defaults
    defaults=$(echo "$1" | tr "," "\n")
    for d in $defaults; do
        if [ -f "/assets/defaults/${d}" ]; then
            print_debug "Container: Getting defaults for $d"
            case "${d}" in
                0*-* | 99-* )
                    output_off
                    source /assets/defaults/"${d}"
                    output_on
                ;;
                * )
                    source /assets/defaults/"${d}"
                ;;
            esac
        else
            print_debug "Container: No defaults available for '${d}'"
        fi
    done
}

# Load function libraries from /assets/functions
# Usage: get_functions [option]
# Options: all, app/single, or comma-separated list of function files
get_functions() {
    if [ -n "$1" ]; then
        case "${1,,}" in
            "all" )
                for f in /assets/functions/*; do
                    if [ "$f" != "/assets/functions/00-container" ]; then
                        print_debug "Container: Getting functions for '${f}'"
                        source "$f"
                    fi
                done
            ;;
            "app" | "single" )
                _process_single_function
            ;;
            * )
                _process_function_list "$1"
            ;;
        esac
    else
        for f in /assets/functions/*; do
            if [ "$f" != "/assets/functions/00-container" ]; then
                print_debug "Container: Getting functions for $f"
                source "${f}"
            fi
        done
    fi
}

# Helper function to process single function file
_process_single_function() {
    local script_path
    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            script_path="$(basename "$0")"
        ;;
        *)
            script_path="$(basename "$PWD")"
        ;;
    esac

    if [ -f "/assets/functions/${script_path}" ]; then
        print_debug "Container: Getting functions for '${script_path}'"
        source /assets/functions/"${script_path}"
    else
        print_debug "Container: No functions available for ${script_path}"
    fi
}

# Helper function to process a list of function files
_process_function_list() {
    local functions
    functions=$(echo "$1" | tr "," "\n")
    for f in $functions; do
        if [ -f "/assets/functions/${f}" ]; then
            print_debug "Container: Getting functions for $f"
            source /assets/functions/"${f}"
        else
            print_debug "Container: No functions available for '$f'"
        fi
    done
}

# Get container image version from changelog files
get_image_version() {
    output_off
    local image_version=""

    if [ -n "${IMAGE_NAME}" ]; then
        local normalized_name="${IMAGE_NAME/\//_}"

        # Try different possible changelog file patterns
        if [ -f "/assets/.changelogs/${normalized_name}.md" ]; then
            image_version=$(head -n1 /assets/.changelogs/${normalized_name}.md | awk '{print $2}')
        elif [ -f /assets/.changelogs/docker-${normalized_name}.md ]; then
            image_version=$(head -n1 /assets/.changelogs/docker-${normalized_name}.md | awk '{print $2}')
        elif [ -f /assets/.changelogs/focela_docker-${normalized_name}.md ]; then
            image_version=$(head -n1 /assets/.changelogs/focela_docker-${normalized_name}.md | awk '{print $2}')
        else
            # Try using repository URL if available
            local strip_image_repo_url=$(echo ${IMAGE_REPO_URL%/} | sed "s#https://github.com/##g")
            if [ -f /assets/.changelogs/${strip_image_repo_url/\//_}.md ]; then
                image_version=$(head -n1 /assets/.changelogs/${strip_image_repo_url/\//_}.md | awk '{print $2}')
            fi
        fi

        if [ -n "${image_version}" ]; then
            echo "${image_version}"
        fi
    fi
    output_on
}

# Add entries to /etc/hosts file for hostname overrides
# Usage: CONTAINER_HOST_OVERRIDE01=destination_ip domain1 domain2 domain3
host_override() {
    local _hostnum=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9].)')

    for (( _host = 1; _host <= _hostnum; _host++ )); do
        local _host_padded=$(printf "%02d" $_host)
        local host_line="CONTAINER_HOST_OVERRIDE_${_host_padded}"
        local host_ip=$(echo ${!host_line} | awk '{print $1}')

        # Resolve hostname to IP if not already an IP
        if [[ ! "${host_ip}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            host_ip="$(getent ahostsv4 "${host_ip}" | grep -m 1 STREAM | awk '{print $1}')"
        fi

        echo "# Added automatically by CONTAINER_HOST_OVERRIDE_${_host_padded}" >> /etc/hosts
        echo "${host_ip} $(echo ${!host_line} | cut -d' ' -f2-)" >> /etc/hosts
    done
}

# Set container timezone
set_timezone() {
    if [ -f /usr/share/zoneinfo/"${TIMEZONE}" ]; then
        if [ "${TIMEZONE}" != "$(cat /etc/timezone)" ]; then
            print_notice "Timezone: Setting to '${TIMEZONE}' from '$(cat /etc/timezone)'"
            cp -R /usr/share/zoneinfo/"${TIMEZONE}" /etc/localtime
            echo "${TIMEZONE}" > /etc/timezone
        fi
    else
        print_warn "Timezone: ${TIMEZONE} does not exist - Using '$(cat /etc/timezone)'"
    fi
}

# Transform file variables into environment variables (Docker Secrets Support)
# Usage: transform_file_var VAR1 VAR2...
transform_file_var() {
    local variables
    variables=$(echo "$@" | tr " " "\n")

    for variable in $variables; do
        if [ -v "${variable}"_FILE ]; then
            local file_variable=${variable}_FILE

            if [ ! -f "${!file_variable}" ]; then
                print_error "[transform_file_var] ${variable}_FILE set as environment variable, however file doesn't exist"
                return 1
            fi

            export "${variable}"="$(cat "${!file_variable}")"
        fi
    done

    unset file_variable
    unset variables
}

#------------------------------------------------------------------------------
# FILE AND DIRECTORY OPERATIONS
#------------------------------------------------------------------------------
# Clone a git repository with optimized space usage
# Usage: clone_git_repo REPO_URL [BRANCH/TAG/COMMIT] [CUSTOM_DEST]
clone_git_repo() {
    set +x
    if [ ${DEBUG_MODE,,} = "true" ]; then set -x; fi

    # Check if git is installed
    if ! [ -x "$(command -v git)" ]; then
        echo '[clone_git_repo] Git is not installed'
        exit 1
    else
        git config --global init.defaultBranch main
    fi

    if [ -z "$1" ]; then
        echo "[clone_git_repo] You tried to call the function but there's no arguments"
        exit 1
    fi

    # Determine repository path
    local repo
    local repo_name
    local repo_text=""

    if [ -n "${3}" ]; then
        repo="${3}/"
        repo_text="to '${3}'"
        repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    else
        repo="/usr/src/$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    fi

    export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repo}"}
    export GIT_REPO_SRC_${repo_name^^}="${repo}"

    if [ -d "${repo}" ]; then
        echo "[clone_git_repo] Directory ${repo} already exists. Cannot clone"
        exit 1
    fi

    # Clone repository
    local append_git_prefix=""
    if [[ $1 != *".git" ]]; then
        append_git_prefix=".git"
    fi

    mkdir -p "${repo}"
    cd "${repo}"
    git init .
    git remote add origin "${1}${append_git_prefix}"

    local repo_commit=""
    if [ -n "${2}" ]; then repo_commit="${2}"; fi

    echo "[clone_git_repo] Cloning Git Repo '${1}' '${2}' ${repo_text}"
    git fetch --depth=1 origin ${repo_commit} +refs/tags/*:refs/tags/*
    git fetch --depth 1 origin ${repo_commit}
    git -c advice.detachedHead=false checkout FETCH_HEAD
    git submodule update --init

    set -x
}

# Create logrotate configuration
# Usage: create_logrotate CONFIG_NAME LOG_PATH [PARSER] [USER] [GROUP]
# Example: create_logrotate cron /var/log/cron/cron.log cron root root
create_logrotate() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        return 1
    fi

    if [ -f /assets/logrotate/"$1" ]; then
        print_debug "Skipping creating automatic logrotation for ${1}"
        return 0
    fi

    print_debug "Creating Logrotate Entry for $2"

    # Set up parser and user if provided
    local lrlsparser=""
    local lruser=""

    if [ -n "$3" ] && [ "${3,,}" != "none" ]; then
        lrlsparser="# logship: $3"
    fi

    if [ -n "$4" ] && [ -n "$5" ]; then
        lruser="    su $4 $5"
    fi

    # Create logrotate config
    if [ ! -d "/assets/logrotate" ]; then
        mkdir -p /assets/logrotate
    fi

    cat <<EOF > /assets/logrotate/"${1}"
${lrlsparser}
$2 {
    missingok
${lruser}
}
EOF
    chown root:root /assets/logrotate/"${1}"
    chmod 0644 /assets/logrotate/"${1}"
}

# Create Zabbix monitoring configuration
# Usage: create_zabbix CONFIG_NAME [AUTOREGISTER_NAME]
create_zabbix() {
    if [ -z "$1" ]; then
        return 1
    fi

    local autoregister="$1"
    if [ -n "$2" ]; then
        autoregister="$2"
    fi

    print_debug "Adding Zabbix Auto Register configuration for '$1'"

    if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
        source /assets/defaults/03-monitoring
        cat <<EOF > "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}.d"/focela_"$1".conf
# Zabbix $1 Configuration - Automatically Generated
# Autoregister=$autoregister
EOF
    fi
}

# Copy custom files from source to destination
# Usage: custom_files DESTINATION [SOURCE] [USER] [GROUP]
custom_files() {
    local ccustom_files_source
    local ccustom_files_destination

    if [ -n "${2}" ]; then
        ccustom_files_source="${1}"
        ccustom_files_destination="${2}"
    else
        ccustom_files_source="${CONTAINER_CUSTOM_PATH}"
        ccustom_files_destination="${1}"
    fi

    if [ -d "${ccustom_files_source}" ] && dir_notempty "${ccustom_files_source}"; then
        print_debug "Custom Files: Copying files from '${ccustom_files_source}' to '${ccustom_files_destination}'"

        if [ -d "${ccustom_files_destination}" ]; then
            mkdir -p "${ccustom_files_destination}"
        fi

        cp -aR "${ccustom_files_source}"/* "${ccustom_files_destination}"/
    fi

    # Set permissions if specified
    local permbuilder=""
    if [ -n "${3}" ]; then permbuilder="${3}"; fi
    if [ -n "${4}" ]; then permbuilder="${3}:${4}"; fi
    if [ -n "${permbuilder}" ]; then chown -R "${permbuilder}" "${ccustom_files_destination}"; fi
}

# Execute custom scripts from a directory
# Usage: custom_scripts [SCRIPTS_DIR]
custom_scripts() {
    local ccustom_scripts_source

    if [ -n "${1}" ]; then
        ccustom_scripts_source="${1}"
    else
        ccustom_scripts_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
    fi

    if [ -d "${ccustom_scripts_source}" ] && dir_notempty "${ccustom_scripts_source}"; then
        for ccustom_script in "${ccustom_scripts_source}"/*.sh; do
            if [ -x "$ccustom_script" ] && [ ! -d "$ccustom_script" ]; then
                print_debug "Custom Script executing: '${ccustom_script}'"
                ${ccustom_script}
            fi
        done
    fi
}

# Check if a directory is empty
dir_empty() {
    [ -z "$(ls -A "$1" 2>/dev/null)" ]
}

# Check if a directory is not empty
dir_notempty() {
    [ -n "$(ls -A "$1" 2>/dev/null)" ]
}

# Install a configuration template
# Usage: install_template USER SOURCE_FILE DESTINATION [MODE]
install_template() {
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        print_error "[install_template] No arguments passed"
        exit 1
    fi

    local template_mode=${4:-"0644"}

    if [ ! -f "$2" ]; then
        print_error "[install_template] Can't find ${2}"
        exit 1
    fi

    if [ ! -d "$(dirname $3)" ]; then
        mkdir -p "$(dirname $3)"
    fi

    chmod "${template_mode}" "${3}"
    chown "${1}" "${3}"
}

# Replace placeholders with values in a template file
# Usage: update_template FILENAME VAR1 VAR2 ...
update_template() {
    local template_files="$1"
    local templates=$(echo "${template_files}" | tr " " "\n")
    shift

    for template_file in $templates; do
        [[ ! -f "${template_file}" ]] && return 1

        local template_variables=($@)
        local template_user=$(stat -c %U "${template_file}")
        local template_tmp_file=$(mktemp)

        cp -a "${template_file}" "${template_tmp_file}"

        for template_variable in ${template_variables[@]}; do
            # Keep compatibility: {{VAR}} => ${VAR}
            sed -ri "s/[{]{2}$template_variable[}]{2}/\${$template_variable}/g" "${template_tmp_file}"
            print_debug "[update_template] Template: '${template_file}' updating field '${template_variable}'"
        done

        # Replace placeholders
        (
            export ${template_variables[@]}
            local IFS=":"
            sudo -HEu ${template_user} envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )

        rm -f "${template_tmp_file}"
    done
}

# Wait for a directory to exist
# Usage: wait_for_directory DIRECTORY_PATH
wait_for_directory() {
    print_debug "Looking for existence of directory: $1"
    while [ ! -d "${1}" ]; do
        sleep 1
    done
}

# Wait for a file to exist
# Usage: wait_for_file FILENAME
wait_for_file() {
    print_debug "Looking for existence of file: $1"
    while [ ! -f "${1}" ]; do
        sleep 1
    done
}

#------------------------------------------------------------------------------
# OUTPUT AND LOGGING FUNCTIONS
#------------------------------------------------------------------------------
# Create log prefix for consistent logging
log_prefix() {
    output_off
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
    fi
    output_on
}

# Disable console output (for reducing log noise)
output_off() {
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        set +x
    fi
}

# Enable console output
output_on() {
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        case "$(basename "$0")" in
            0*-* | 99-* )
                : # Do nothing
            ;;
            run )
                case "$PWD" in
                    */0*-* | 99-* )
                        : # Do nothing
                    ;;
                    * )
                        set -x
                    ;;
                esac
            ;;
            * )
                set -x
            ;;
        esac
    fi
}

# Common logging function to reduce code duplication
# Usage: _log_message LEVEL COLOR MESSAGE
_log_message() {
    local level="$1"
    local color="$2"
    local message="$3"
    local console_output=false
    local file_output=false

    # Determine if we should log to console based on log level
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug")
            if [[ "$level" =~ ^(DEBUG|NOTICE|WARN|ERROR|INFO|STARTING)$ ]]; then
                console_output=true
            fi
            ;;
        "notice")
            if [[ "$level" =~ ^(NOTICE|WARN|ERROR|INFO|STARTING)$ ]]; then
                console_output=true
            fi
            ;;
        "warn")
            if [[ "$level" =~ ^(WARN|ERROR|INFO|STARTING)$ ]]; then
                console_output=true
            fi
            ;;
        "error")
            if [[ "$level" =~ ^(ERROR|INFO|STARTING)$ ]]; then
                console_output=true
            fi
            ;;
        *)
            if [[ "$level" =~ ^(INFO|STARTING)$ ]]; then
                console_output=true
            fi
            ;;
    esac

    # Determine if we should log to file based on log level
    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug")
            if [[ "$level" =~ ^(DEBUG|NOTICE|WARN|ERROR|INFO|STARTING)$ ]]; then
                file_output=true
            fi
            ;;
        "notice")
            if [[ "$level" =~ ^(NOTICE|WARN|ERROR|INFO|STARTING)$ ]]; then
                file_output=true
            fi
            ;;
        "warn")
            if [[ "$level" =~ ^(WARN|ERROR|INFO|STARTING)$ ]]; then
                file_output=true
            fi
            ;;
        "error")
            if [[ "$level" =~ ^(ERROR|INFO|STARTING)$ ]]; then
                file_output=true
            fi
            ;;
        *)
            if [[ "$level" =~ ^(INFO|STARTING)$ ]]; then
                file_output=true
            fi
            ;;
    esac

    # Output to console if needed
    if [ "$console_output" = true ]; then
        if [ "${DEBUG_MODE,,}" = "true" ]; then
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[${level}] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $message"
            else
                echo -e "$(log_prefix)${color}[${level}]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $message"
            fi
        else
            if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                echo -e "$(log_prefix)[${level}] ** [${PROCESS_NAME}] $message"
            else
                echo -e "$(log_prefix)${color}[${level}]${boff} ** [${PROCESS_NAME}] $message"
            fi
        fi
    fi

    # Output to log file if needed
    if [ "$file_output" = true ]; then
        echo -e "$(log_prefix)[${level}] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $message" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    fi
}

# Print debug level message
print_debug() {
    output_off
    _log_message "DEBUG" "${bdm}" "$1"
    output_on
}

# Print error level message
print_error() {
    output_off
    _log_message "ERROR" "${blr}" "$1"
    output_on
}

# Print info level message
print_info() {
    output_off
    _log_message "INFO" "${bdg}" "$1"
    output_on
}

# Print notice level message
print_notice() {
    output_off
    _log_message "NOTICE" "${bdgy}" "$1"
    output_on
}

# Print startup message
print_start() {
    output_off
    local proc_start_wrapper=""
    local proc_start_count=""

    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ]; then
        if [ -f /tmp/.container/"$(basename $PWD)" ]; then
            proc_start_count=$(cat /tmp/.container/"$(basename $PWD)" | wc -l)
            proc_start_wrapper="[${proc_start_count}] "
        fi

        if [ -z "${proc_start_count}" ]; then
            proc_start_count=1
        fi

        local proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$(pwd)") ${proc_start_count} $(cat /etc/hostname)"
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh "${proc_help_arg}"
            elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh "${proc_help_arg}"
            fi
        fi

        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ]; then
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ]; then
                if [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                    SHOW_OUTPUT=TRUE
                fi
            fi

            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
                print_error "POTENTIAL RUNWAY DETECTED: Disabling $(basename $PWD) service because it has tried restarting '${CONTAINER_PROCESS_RUNAWAY_LIMIT}' times"
                s6-svc -d /var/run/s6/legacy-services/$(basename "$PWD")
                sleep 3
                exit 1
            fi

            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ]; then
                sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"
            fi
        fi
    fi

    _log_message "STARTING" "${bdg}" "${proc_start_wrapper}$1"
    output_on
}

# Print warning level message
print_warn() {
    output_off
    _log_message "WARN" "${bdb}" "$1"
    output_on
}

# Run a command with no output
silent() {
    if [ "${DEBUG_MODE}" = "true" ] || [ "${SHOW_OUTPUT,,}" = "true" ] || [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
        "$@"
    else
        "$@" > /dev/null 2>&1
    fi
}

# Display container information banner
showoff() {
    output_off
    if [ -n "${IMAGE_NAME}" ]; then
        local iv=$(get_image_version)
        local is="$(echo 'H4sIAAAAAAAAA/PMTUxPtVLgAgDj9n4BCAAAAA==' | base64 -d | gunzip) ${IMAGE_NAME}"

        if [ -n "${iv// }" ]; then
            is="${is}$(echo 'H4sIAAAAAAAAA1OoUQhLLSrOzM9TUOACAAiVoSgNAAAA' | base64 -d | gunzip)${iv}$(echo 'H4sIAAAAAAAAA1MIqSxIVVDPzE1MT41PzkjMS0/NyU9XV0jLL1JISS1JzMwp5gIAZRrZYCQAAAA=' | base64 -d | gunzip)"
        fi

        if [ -n "${IMAGE_REPO_URL}" ]; then
            local ir="$(echo 'H4sIAAAAAAAAAwtKLcgvzizJL6rUd8lPLs1NzStJLMnMz7PiAgAxTVbtGgAAAA==' | base64 -d | gunzip) ${IMAGE_REPO_URL}"
        fi
    fi

    echo "H4sIAAAAAAAAA61RQRLEIAi78wpvXAq971t68CE8vgni2s7urWUGEyRBHVt7JTYzc+Ga4WD+T+Q/pm9jmQNbIZpNN9OOpGSqnA6I4jJlp1RZZ2OZUbrK3B9nxWw5VB9NiOFNCt5ta8s0kSD3suiBxOQDRh0WxSWQcbuYj9Mp4KuksKAoOVm3qlvRfq1Vl4Nj5fkvZnCsnEeFItgXAgAA" | base64 -d | gunzip
    echo "${is}"
    echo "${ir}"
    echo "H4sIAAAAAAAAA/PJTE7NK061UvD1DFGoUTi0UsHIwMhEwSWxLFXBOT+vKL+SCwCc9R6MIwAAAA==" | base64 -d | gunzip
    echo ""
    echo "H4sIAAAAAAAAA22MsRXCMAwF+0zxB4DQ01JRMISIZdDDtowkJy/bkwG46t4Vd8+Itzik0ovRTVdJ7Nh1YKUyGDjjps2PavB+mJq0F+qOTe2DrIZFW0gbnDAlXrlor9zihJDKZcfoiYL9BGoJmSmGMYy/gz18Pu61si1CBT56VwvQSlLoWXieJvzhocfh3rJegXdE9+vlsm3bHGKcNEvMC00/MF6uwtoAAAA=" | base64 -d | gunzip
    echo ""
    output_on
}

#------------------------------------------------------------------------------
# PACKAGE MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------------
# Package management operations (install, remove, update, upgrade, cleanup)
# Usage: package COMMAND [ARGUMENTS]
package() {
    output_off
    local distro=$(cat /etc/os-release | grep ^ID= | cut -d = -f2)
    local action="${1}"
    shift
    local arguments=$@

    # Define subfunctions for package operations

    # Clean up package cache
    cleanup() {
        case "${distro}" in
            "alpine" )
                rm -rf /root/.gitconfig
                rm -rf /var/cache/apk/*
            ;;
            "debian" | "ubuntu" )
                apt-get clean -y
                rm -rf /root/.gitconfig
                rm -rf /var/lib/apt/lists/*
            ;;
        esac
    }

    # Install a package
    install() {
        case "${distro}" in
            "alpine" )
                local dependencies=""
                if [[ "${1}" =~ ^\..* ]]; then
                    dependencies="-t"
                fi
                apk add ${dependencies} $@
            ;;
            "debian" | "ubuntu" )
                if [[ "${1}" =~ ^\..* ]]; then
                    shift
                fi
                apt-get install -y --no-install-recommends $@
            ;;
        esac
    }

    # Remove a package
    remove() {
        case "${distro}" in
            "alpine" )
                apk del $@
            ;;
            "debian" | "ubuntu" )
                local packages="$@"
                if [[ "${packages}" =~ \..* ]]; then
                    packages=$(echo "${packages}" | sed "s|\..* ||g")
                fi
                apt-get purge -y ${packages}
                apt-get autoremove -y
            ;;
        esac
    }

    # Update package repository
    update() {
        case "${distro}" in
            "alpine" )
                apk update
            ;;
            "debian" | "ubuntu" )
                apt-get update
            ;;
        esac
    }

    # Upgrade installed packages
    upgrade() {
        case "${distro}" in
            "alpine" )
                apk upgrade
            ;;
            "debian" | "ubuntu" )
                apt-get upgrade -y
            ;;
        esac
    }

    # Process the command
    case "${action}" in
        add | install )
            install "${arguments}"
        ;;
        delete | remove | uninstall )
            remove "${arguments}"
        ;;
        * )
            "${action}" "${arguments}"
        ;;
    esac
    output_on
}

#------------------------------------------------------------------------------
# DATABASE FUNCTIONS
#------------------------------------------------------------------------------
# Check if database is ready for connections
# Usage: db_ready DATABASE_TYPE
db_ready() {
    output_off
    print_debug "Checking to see if Database Type $1 is ready"

    case "${1,,}" in
        "couch" | "couchdb" )
            _db_ready_couch
        ;;
        "influx" | "influxdb" )
            _db_ready_influx
        ;;
        "mongo" | "mongodb" )
            _db_ready_mongo
        ;;
        "mysql" | "mariadb" )
            _db_ready_mysql
        ;;
        "pgsql" | "psql" | "postgres" | "postgresql" )
            _db_ready_postgres
        ;;
        "rabbit" | "rabbitmq" )
            _db_ready_rabbit
        ;;
        "redis" )
            _db_ready_redis
        ;;
        "rethink" )
            _db_ready_rethink
        ;;
    esac
    output_on
}

# CouchDB ready check
_db_ready_couch() {
    transform_file_var DB_PORT
    transform_file_var COUCHDB_PORT

    local couch_port=${COUCHDB_PORT:-${DB_PORT:-5984}}

    transform_file_var DB_HOST
    transform_file_var COUCHDB_HOST

    local couch_host=${COUCHDB_HOST:-${DB_HOST}}
    local counter=0

    while ! (nc -z "${couch_host}" ${couch_port}); do
        sleep 5
        (( counter+=5 ))
        print_warn "CouchDB Host '${couch_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# InfluxDB ready check
_db_ready_influx() {
    transform_file_var DB_PORT
    transform_file_var INFLUXDB_PORT

    local influx_port=${INFLUXDB_PORT:-${DB_PORT:-8088}}

    transform_file_var DB_HOST
    transform_file_var INFLUXDB_HOST

    local influx_host=${INFLUXDB_HOST:-${DB_HOST}}
    local counter=0

    while ! (nc -z "${influx_host}" "${influx_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "InfluxDB Host '${influx_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# MongoDB ready check
_db_ready_mongo() {
    transform_file_var DB_PORT
    transform_file_var MONGO_PORT

    local mongo_port=${MONGO_PORT:-${DB_PORT:-27017}}

    transform_file_var DB_HOST
    transform_file_var MONGO_HOST

    local mongo_host=${MONGO_HOST:-${DB_HOST}}
    local counter=0

    while ! (nc -z "${mongo_host}" "${mongo_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "Mongo Host '${mongo_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# MySQL/MariaDB ready check
_db_ready_mysql() {
    local mysqladmin_bin

    if command -v "mariadb-admin" &> /dev/null; then
        mysqladmin_bin="$(which mariadb-admin)"
    elif command -v "mysqladmin" &> /dev/null; then
        mysqladmin_bin="$(which mysqladmin)"
    else
        print_error "No MySQL or MariaDB client detected - Cannot check for Database"
        exit 1
    fi

    if [ ! -f /etc/my.cnf.d/disable-ssl.cnf ]; then
        cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
    fi

    # Set up connection parameters
    transform_file_var DB_PORT MYSQL_PORT MARIA_PORT
    local maria_port=${MARIA_PORT:-${MYSQL_PORT:-${DB_PORT:-3306}}}

    transform_file_var DB_HOST MYSQL_HOST MARIA_HOST
    local maria_host=${MARIA_HOST:-${MYSQL_HOST:-${DB_HOST}}}

    transform_file_var DB_USER MYSQL_USER MARIA_USER
    local maria_user=${MARIA_USER:-${MYSQL_USER:-${DB_USER}}}

    transform_file_var DB_PASS MYSQL_PASS MARIA_PASS
    local maria_pass=${MARIA_PASS:-${MYSQL_PASS:-${DB_PASS}}}

    transform_file_var DB_NAME MYSQL_NAME MARIA_NAME
    local maria_name=${MARIA_NAME:-${MYSQL_NAME:-${DB_NAME}}}

    local counter=0

    while ! ("${mysqladmin_bin}" -u"${maria_user}" -P"${maria_port}" -h"${maria_host}" -p"${maria_pass}" status > /dev/null 2>&1); do
        sleep 5
        (( counter+=5 ))
        print_warn "MySQL/MariaDB Server '${maria_host}' is not accessible, retrying.. (${counter} seconds so far)"
    done
}

# PostgreSQL ready check
_db_ready_postgres() {
    local pg_isready_bin

    if command -v "pg_isready" &> /dev/null; then
        pg_isready_bin="$(which pg_isready)"
    else
        print_error "No PostgreSQL client installation detected - Cannot check for Database"
        exit 1
    fi

    # Set up connection parameters
    transform_file_var DB_PORT POSTGRES_PORT
    local postgres_port=${POSTGRES_PORT:-${DB_PORT:-5432}}

    transform_file_var DB_HOST POSTGRES_HOST
    local postgres_host=${POSTGRES_HOST:-${DB_HOST}}

    transform_file_var DB_USER POSTGRES_USER
    local postgres_user=${POSTGRES_USER:-${DB_USER}}

    transform_file_var DB_PASS PGPASSWORD
    local postgres_pass=${PGPASSWORD:-${DB_PASS}}

    transform_file_var DB_NAME POSTGRES_NAME
    local postgres_name=${POSTGRES_NAME:-${DB_NAME}}

    local counter=0
    export PGPASSWORD=${postgres_pass}

    until "${pg_isready_bin}" --dbname="${postgres_name}" --host="${postgres_host}" --port="${postgres_port}" --username="${postgres_user}" -q; do
        sleep 5
        (( counter+=5 ))
        print_warn "Postgres Host '${postgres_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# RabbitMQ ready check
_db_ready_rabbit() {
    transform_file_var DB_PORT RABBIT_PORT
    local rabbit_port=${RABBIT_PORT:-${DB_PORT:-5672}}

    transform_file_var DB_HOST RABBIT_HOST
    local rabbit_host=${RABBIT_HOST:-${DB_HOST}}

    local counter=0

    while ! (nc -z "${rabbit_host}" "${rabbit_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "RabbitMQ Host '${rabbit_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# Redis ready check
_db_ready_redis() {
    transform_file_var DB_PORT REDIS_PORT
    local redis_port=${REDIS_PORT:-${DB_PORT:-6379}}

    transform_file_var DB_HOST REDIS_HOST
    local redis_host=${REDIS_HOST:-${DB_HOST}}

    local counter=0

    while ! (nc -z "${redis_host}" "${redis_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "Redis Host '${redis_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# RethinkDB ready check
_db_ready_rethink() {
    transform_file_var DB_PORT RETHINK_PORT
    local rethink_port=${RETHINK_PORT:-${DB_PORT:-28015}}

    transform_file_var DB_HOST RETHINK_HOST
    local rethink_host=${RETHINK_HOST:-${DB_HOST}}

    local counter=0

    while ! (nc -z "${rethink_host}" "${rethink_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "RethinkDB Host '${rethink_host}' is not accessible, retrying.. ($counter seconds so far)"
    done
}

# Perform database sanity checks
# Usage: sanity_db DATABASE_TYPE
sanity_db() {
    output_off

    if [ -z "$1" ]; then
        # Legacy handling - will be deprecated
        print_debug "Using Legacy db_ready command - please upgrade"
        transform_file_var DB_HOST
        if [ -z "${DB_HOST}" ]; then
            print_error "No Database Host Entered! - Set '\$DB_HOST'"
            exit 1
        fi

        transform_file_var DB_NAME
        if [ -z "${DB_NAME}" ]; then
            print_error "No Database Name Entered! - Set '\$DB_NAME'"
            exit 1
        fi

        transform_file_var DB_USER
        if [ -z "${DB_USER}" ]; then
            print_error "No Database User Entered! - Set '\$DB_USER'"
            exit 1
        fi

        transform_file_var DB_PASS
        if [ -z "${DB_PASS}" ]; then
            print_error "No Database Password Entered! - Set '\$DB_PASS'"
            exit 1
        fi
        output_on
        return 0
    fi

    case "${1,,}" in
        "couch" | "couchdb" )
            print_debug "Checking Couch DB Parameters"
            transform_file_var DB_HOST COUCH_HOST
            local couch_host=${COUCH_HOST:-${DB_HOST}}

            if [ -z "${couch_host}" ]; then
                print_error "No Couch Database Host Entered! - Set '\$DB_HOST' or '\$COUCH_HOST'"
                exit 1
            fi
        ;;
        "influx" | "influxdb")
            print_debug "Checking Influx DB Parameters"
            transform_file_var DB_HOST INFLUX_HOST
            local influx_host=${INFLUX_HOST:-${DB_HOST}}

            if [ -z "${influx_host}" ]; then
                print_error "No Influx Database Host Entered! - Set '\$DB_HOST' or '\$INFLUX_HOST'"
                exit 1
            fi
        ;;
        "mongo" | "mongodb" )
            print_debug "Checking Mongo DB Parameters"
            transform_file_var DB_HOST MONGO_HOST
            local mongo_host=${MONGO_HOST:-${DB_HOST}}

            if [ -z "${mongo_host}" ]; then
                print_error "No Mongo Database Host Entered! - Set '\$DB_HOST' or '\$MONGO_HOST'"
                exit 1
            fi
        ;;
        "mysql" | "mariadb" )
            print_debug "Checking MariaDB DB Parameters"
            transform_file_var DB_HOST MYSQL_HOST MARIA_HOST
            local maria_host=${MARIA_HOST:-${MYSQL_HOST:-${DB_HOST}}}

            transform_file_var DB_USER MYSQL_USER MARIA_USER
            local maria_user=${MARIA_USER:-${MYSQL_USER:-${DB_USER}}}

            transform_file_var DB_PASS MYSQL_PASS MARIA_PASS
            local maria_pass=${MARIA_PASS:-${MYSQL_PASS:-${DB_PASS}}}

            transform_file_var DB_NAME MYSQL_NAME MARIA_NAME
            local maria_name=${MARIA_NAME:-${MYSQL_NAME:-${DB_NAME}}}

            if [ -z "${maria_host}" ]; then
                print_error "No MariaDB Database Host Entered! - Set '\$DB_HOST' or '\$MARIA_HOST'"
                exit 1
            fi
            if [ -z "${maria_name}" ]; then
                print_error "No MariaDB Database Name Entered! - Set '\$DB_NAME' or '\$MARIA_NAME'"
                exit 1
            fi
            if [ -z "${maria_user}" ]; then
                print_error "No MariaDB Database USER Entered! - Set '\$DB_USER' or '\$MARIA_USER'"
                exit 1
            fi
            if [ -z "${maria_pass}" ]; then
                print_error "No MariaDB Database Pass Entered! - Set '\$DB_PASS' or '\$MARIA_PASS'"
                exit 1
            fi
        ;;
        "pgsql" | "psql" | "postgres" | "postgresql" )
            print_debug "Checking Postgres DB Parameters"
            transform_file_var DB_HOST POSTGRES_HOST
            local postgres_host=${POSTGRES_HOST:-${DB_HOST}}

            transform_file_var DB_USER POSTGRES_USER
            local postgres_user=${POSTGRES_USER:-${DB_USER}}

            transform_file_var DB_PASS PGPASSWORD
            local postgres_pass=${PGPASSWORD:-${DB_PASS}}

            transform_file_var DB_NAME POSTGRES_NAME
            local postgres_name=${POSTGRES_NAME:-${DB_NAME}}

            if [ -z "${postgres_host}" ]; then
                print_error "No PostgreSQL Database Host Entered! - Set '\$DB_HOST' or '\$POSTGRES_HOST'"
                exit 1
            fi
            if [ -z "${postgres_name}" ]; then
                print_error "No PostgreSQL Database Name Entered! - Set '\$DB_NAME' or '\$POSTGRES_NAME'"
                exit 1
            fi
            if [ -z "${postgres_user}" ]; then
                print_error "No PostgreSQL Database USER Entered! - Set '\$DB_USER' or '\$POSTGRES_USER'"
                exit 1
            fi
            if [ -z "${postgres_pass}" ]; then
                print_error "No PostgreSQL Database Pass Entered! - Set '\$DB_PASS' or '\$POSTGRES_PASS'"
                exit 1
            fi
        ;;
        "rabbit" | "rabbitmq" )
            transform_file_var DB_HOST RABBIT_HOST RABBITMQ_HOST
            local rabbit_host=${RABBITMQ_HOST:-${RABBIT_HOST:-${DB_HOST}}}

            if [ -z "${rabbit_host}" ]; then
                print_error "No RabbitMQ Database Host Entered! - Set '\$DB_HOST' or '\$RABBIT_HOST'"
                exit 1
            fi
        ;;
        "redis" )
            print_debug "Checking Redis DB Parameters"
            transform_file_var DB_HOST REDIS_HOST
            local redis_host=${REDIS_HOST:-${DB_HOST}}

            if [ -z "${redis_host}" ]; then
                print_error "No Redis Database Host Entered! - Set '\$DB_HOST' or '\$REDIS_HOST'"
                exit 1
            fi
        ;;
        "rethink" )
            print_debug "Checking RethinkDB DB Parameters"
            transform_file_var DB_HOST RETHINK_HOST
            local rethink_host=${RETHINK_HOST:-${DB_HOST}}

            if [ -z "${rethink_host}" ]; then
                print_error "No Rethink Database Host Entered! - Set '\$DB_HOST' or '\$RETHINK_HOST'"
                exit 1
            fi
        ;;
    esac

    output_on
}

# Wait for a port to be available
# Usage: wait_for_port HOSTNAME PORT
wait_for_port() {
    print_debug "Looking for existence of listening port on $1:$2"
    local counter=0

    while ! (nc -z "${1}" "${2}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "Host '${1}' is not listening on port '${2}', retrying.. ($counter seconds so far)"
    done
}

# Wait for a socket to be available
# Usage: wait_for_socket SOCKET_PATH
wait_for_socket() {
    print_debug "Looking for existence of socket: $1"

    while [ ! -S "${1}" ]; do
        sleep 1
    done
}

#------------------------------------------------------------------------------
# PERMISSION MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------------
# Grant doas permission to a user
# Usage: grant_doas USERNAME [COMMAND]
grant_doas() {
    output_off

    if [ -z "$1" ]; then
        return 1
    fi

    print_debug "Adding Doas privileges to '$1'"
    local doas_command=""

    if [ -n "$2" ]; then
        print_debug="Adding doas privileges to '$1' for '$2' command"
        doas_command="cmd $2"
    fi

    echo "permit nopass $1 ${doas_command} as root" >> /etc/doas.conf
    chown root:root /etc/doas.conf
    chmod 0400 -R /etc/doas.conf

    output_on
}

# Grant sudo permission to a user
# Usage: grant_sudo USERNAME [COMMAND]
# Note: Will be deprecated in future releases. Use "grant_doas" instead
grant_sudo() {
    output_off

    if [ -z "$1" ]; then
        return 1
    fi

    local sudo_command="ALL"
    if [ -n "$2" ]; then
        sudo_command="$2"
    fi

    print_debug "Adding Sudo privileges to '$1' for '${sudo_command}' command"
    echo "%$1 ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers

    output_on
}

#------------------------------------------------------------------------------
# VALIDATION AND CONVERSION FUNCTIONS
#------------------------------------------------------------------------------
# Check if a variable is defined
# Usage: sanity_var VARNAME DESCRIPTION
sanity_var() {
    output_off
    print_debug "Looking for existence of $1 environment variable"

    if [ ! -v "$1" ]; then
        print_error "No '$2' Entered! - Set '\$$1'"
        exit 1
    fi

    output_on
}

# Convert true/false to yes/no
# Usage: truefalse_yesno VARNAME [CASE]
# CASE options: uppercase/upper/uc, lowercase/lower/lc
truefalse_yesno() {
    local value=$(set | grep "${1}"= | cut -d '=' -f2)
    local var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
        print_debug "Converting Variable Name ${var} value to 'yes'"
        unset "$1"

        if [ -n "$2" ]; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=YES"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=yes"
                ;;
            esac
        else
            export "$1=yes"
        fi
    elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
        print_debug "Converting Variable Name ${var} value to 'no'"
        unset "$1"

        if [ -n "$2" ]; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=NO"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=no"
                ;;
            esac
        else
            export "$1=no"
        fi
    fi
}

# Convert true/false to on/off
# Usage: truefalse_onoff VARNAME [CASE]
# CASE options: uppercase/upper/uc, lowercase/lower/lc
truefalse_onoff() {
    local value=$(set | grep "${1}"= | cut -d '=' -f2)
    local var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
        print_debug "Converting Variable Name ${var} value to 'On'"
        unset "$1"

        if [ -n "$2" ]; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=ON"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=on"
                ;;
            esac
        else
            export "$1=ON"
        fi
    elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
        print_debug "Converting Variable Name ${var} value to 'Off'"
        unset "$1"

        if [ -n "$2" ]; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=OFF"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=off"
                ;;
            esac
        else
            export "$1=off"
        fi
    fi
}

# Convert true/false to 1/0
# Usage: truefalse_onezero VARNAME
truefalse_onezero() {
    local value=$(set | grep "${1}"= | cut -d '=' -f2)
    local var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
        print_debug "Converting Variable Name ${var} value to '1'"
        unset "$1"
        export "$1=1"
    elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
        print_debug "Converting Variable Name ${var} value to '0'"
        unset "$1"
        export "$1=0"
    fi
}

# Check if a variable is set to false/no
# Usage: if var_false $VARNAME; then ... fi
var_false() {
    [ "${1,,}" = "false" ] || [ "${1,,}" = "no" ]
}

# Check if a variable is not set to false
# Usage: if var_notfalse $VARNAME; then ... fi
var_notfalse() {
    [ "${1,,}" != "false" ]
}

# Check if a variable is not set to true
# Usage: if var_nottrue $VARNAME; then ... fi
var_nottrue() {
    [ "${1,,}" != "true" ]
}

# Check if a variable is set to true/yes
# Usage: if var_true $VARNAME; then ... fi
var_true() {
    [ "${1,,}" = "true" ] || [ "${1,,}" = "yes" ]
}

# Convert yes/no to true/false
# Usage: yesno_truefalse VARNAME [CASE]
# CASE options: uppercase/upper/uc, lowercase/lower/lc
yesno_truefalse() {
    local value=$(set | grep "${1}"= | cut -d '=' -f2)
    local var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
        print_debug "Converting Variable Name ${var} value to 'TRUE'"
        unset "$1"

        if [ -n "$2" ]; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=TRUE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=true"
                ;;
            esac
        else
            export "$1=TRUE"
        fi
    elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
        print_debug "Converting Variable Name ${var} value to 'FALSE'"
        unset "$1"

        if [ -n "$2" ]; then
            case "$2" in
                "uppercase" | "upper" | "uc" )
                    export "$1=FALSE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=false"
                ;;
            esac
        else
            export "$1=FALSE"
        fi
    fi
}

# Debug mode handling based on environment variables
case "${DEBUG_MODE}" in
    "TRUE" | "true" | "YES" | "yes" | "ON" | "on" )
        CONTAINER_LOG_LEVEL="DEBUG"
        set -x
    ;;
    "FALSE" | "false" | "NO" | "no" | "OFF" | "off" )
        :
    ;;
    * )
        if [ "$(dirname "$0")" = "/var/run/s6/etc/cont-init.d" ] || [ "$(dirname "$0")" = "/etc/cont-init.d" ]; then
            if [ "${DEBUG_MODE}" = "$(basename \""$0"\")" ]; then
                print_notice "Enabling Debug mode for $(basename \""$0"\") scripts"
                set -x
            fi
        fi
        if [ "${DEBUG_MODE}" = "$(basename "$PWD")" ]; then
            print_notice "Enabling Debug mode for $(basename "$PWD") scripts"
            set -x
        fi
    ;;
esac
